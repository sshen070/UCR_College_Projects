  #include "HashTable.h"
  #include "WordEntry.h"

  /* HashTable constructor
  *  input s is the size of the array
  *  set s to be size
  *  initialize array of lists of WordEntry
  */
  HashTable::HashTable (int s) : size(s) {
    hashTable = new list<WordEntry>[size];
  }

  // Destructor -> deletes the array of lists of WordEntry created in the constructor
  HashTable::~HashTable() {
    delete[] hashTable;
  }

  /* computeHash
  *  return an integer based on the input string
  *  used for index into the array in hash table
  *  be sure to use the size of the array to 
  *  ensure array index doesn't go out of bounds
  * 
  * Generously generated by ChatGPT
  * Credit to Dan Bernstein for his "djb2" algorithm
  */
  int HashTable::computeHash(const string &s) const {
    unsigned long hash = 5381;
    for (char c : s) {
      // hash << 5 -> shifts the bits to the left 5 places -> *32 the value
      hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }
    return hash % size; // Hash value must be bounded by the size of the array
  }

  /* put
  *  input: string word and int score to be inserted
  *  First, look to see if word already exists in hash table
  *   if so, addNewAppearence with the score to the WordEntry
  *   if not, create a new Entry and push it on the list at the
  *   appropriate array index
  */
  void HashTable::put(const string &s, int score) {
    int hashVal = computeHash(s);

    for (WordEntry& entry : hashTable[hashVal % size]) {
      if (entry.getWord() == s) {  // If the word already exists in the table -> add score
        entry.addNewAppearance(score);
        return;
      }
    }
    // Otherwise create a new entry add it to the hash table
    WordEntry newEntry = WordEntry(s, score);
    hashTable[hashVal % size].push_back(newEntry);
  }

  /* getAverage
  *  input: string word 
  *  output: the result of a call to getAverage()
  *          from the WordEntry
  *  Must first find the WordEntry in the hash table
  *  then return the average
  *  If not found, return the value 2.0 (neutral result)
  */
  double HashTable::getAverage(const string &s) const {
    int hashVal = computeHash(s);

    for (WordEntry& entry : hashTable[hashVal % size]) {
      if (entry.getWord() == s) {
        return entry.getAverage();  // If the word is in the table -> return its average
      }
    }
    return 2.0;  // Return default if missing
  }

  /* contains
  * input: string word
  * output: true if word is in the hash table
  *         false if word is not in the hash table
  */
  bool HashTable::contains(const string &s) const {
    int hashVal = computeHash(s);

    for (WordEntry& entry : hashTable[hashVal % size]) {
      if (entry.getWord() == s) {
        return true;
      }
    }
    return false;
  }
